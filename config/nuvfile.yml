# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

version: '3'
vars:
  VAR: ""
  MSG: ""
  VAL: ""

tasks:
  
  apihost:
    silent: true
    cmds:
    - config NUVOLARIS_APIHOST="{{._apihost_}}"
    - config -dump | grep NUVOLARIS_APIHOST
    - |
      if test -n "{{.__tls}}" 
      then config NUVOLARIS_TLSEMAIL="{{.__tls}}" NUVOLARIS_TLS=true
      else config NUVOLARIS_TLSEMAIL="none" NUVOLARIS_TLS=false
      fi
    - config -dump | grep NUVOLARIS_TLS

  enable:
    silent: true
    cmds:
    - |
      if {{.__redis}} || {{.__all}}
      then config NUVOLARIS_REDIS=true
      fi
      if {{.__mongodb}} || {{.__all}}
      then 
        config NUVOLARIS_MONGODB=true

        if {{.__mongodb}}
        then echo 'MongoDB (FerretDB) deployment requires PosgresSQL. Enabling it.'
             config NUVOLARIS_POSTGRES=true
        fi    
      fi
      if {{.__minio}} || {{.__all}}
      then config NUVOLARIS_MINIO=true
      fi
      if {{.__cron}} || {{.__all}}
      then config NUVOLARIS_CRON=true
      fi
      if {{.__static}} || {{.__all}}
      then config NUVOLARIS_STATIC=true
      fi
      if {{.__postgres}} || {{.__all}}
      then config NUVOLARIS_POSTGRES=true
      fi      
    - task: status

  disable:
    silent: true
    cmds:
    - |
      if {{.__redis}} || {{.__all}}
      then config NUVOLARIS_REDIS=false
      fi
      if {{.__mongodb}} || {{.__all}}
      then config NUVOLARIS_MONGODB=false
      fi
      if {{.__minio}} || {{.__all}}
      then config NUVOLARIS_MINIO=false
      fi
      if {{.__cron}} || {{.__all}}
      then config NUVOLARIS_CRON=false
      fi
      if {{.__static}} || {{.__all}}
      then config NUVOLARIS_STATIC=false
      fi
      if {{.__postgres}} || {{.__all}}
      then config NUVOLARIS_POSTGRES=false
        if {{.__postgres}}
          then echo 'Disabling PosgresSQL forces deactivation of MongoDB (FerretDB)'
               config NUVOLARIS_MONGODB=false
        fi
      fi      
    - task: status

  status:
    silent: true
    cmds:
    - cmd: config -dump | grep NUVOLARIS_
      ignore_error: true
    - cmd: config -dump | grep AKS_
      ignore_error: true
    - cmd: config -dump | grep EKS_
      ignore_error: true
    - cmd: config -dump | grep GKE_
      ignore_error: true

  export:
    silent: true
    cmds:
    - config -dump | awk '{print "export "$0}'
    - |
      echo NUV_TMP=$NUV_TMP
      echo 'DATA:() {' 
      echo '  DATA="$(eval $@)"' 
      echo '}'
      echo alias RUN:=

  reset:
    silent: true
    cmds:
    - rm ~/.nuv/config.json
    - rm "$NUV_TMP/runtimes.json"
    - config -dump

  # read a value, empty => use a default
  read:
    silent: true
    cmds:
    - test -n "{{.VAR}}" || die "specify variable VAR="
    - test -n "{{.MSG}}" || die "specify message MSG="
    - test -n "{{.DEF}}" || die "specify default DEF="
    - |
      if test -z "{{.VAL}}"
      then  
        echo "*** Please, specify {{.MSG}} and press enter."
        test -n "{{.HINT}}" && echo "{{.HINT}}"
        if test -z "${{.VAR}}"
        then def="{{.DEF}}"
        else def="${{.VAR}}"
        fi
        echo "Just press enter for default [$def]: "
        read input
        if test -z "$input"
        then input="$def"
        fi
      else input="{{.VAL}}"
      fi
      config {{.VAR}}="$input"

  # read a value, empty is not accepted
  readforce:
    silent: true
    cmds:
    - test -n "{{.VAR}}" || die "specify variable VAR="
    - test -n "{{.MSG}}" || die "specify message MSG="
    - |
      input="{{.VAL}}"
      while test -z "$input"
      do 
        echo "*** Please, specify {{.MSG}} and press enter."
        test -n "{{.HINT}}" && echo "{{.HINT}}"
        read input
      done
      config {{.VAR}}="$input"

  aws:
    silent: true
    cmds:
    - task: readforce
      vars:
        MSG: "AWS Access Id"
        VAR: "AWS_ACCESS_KEY_ID"
        VAL: "{{.__access}}"
    - task: readforce
      vars:
        MSG: "AWS Secret Key"
        VAR: "AWS_SECRET_ACCESS_KEY"
        VAL: "{{.__secret}}"
    - task: read
      vars:
        MSG: "AWS Region to use"
        VAR: "AWS_DEFAULT_REGION"
        HINT: | 
              To get a list of valid values use:
                aws ec2 describe-regions --output table
        VAL: "{{.__region}}"
        DEF: "us-east-1"
    - task: read
      vars:
        MSG: "AWS Image to use for VMs"
        VAR: "AWS_VM_IMAGE_ID"
        HINT: | 
              The suggested image is an Ubuntu 22 valid only for us-east-1
              Please check AWS website for alternative images in other zones
        VAL: "{{.__image}}"
        DEF: "ami-052efd3df9dad4825"
    - task: read
      vars:
        MSG: "AWS Default user for image to use for VMs"
        VAR: "AWS_VM_IMAGE_USER"
        HINT: | 
              Default user to access the selected image.
        VAL: "{{.__vmuser}}"
        DEF: "ubuntu"
    - task: read
      vars:
          MSG: "AWS Instance type to use for VMs"
          VAR: "AWS_VM_INSTANCE_TYPE"
          HINT: | 
                The suggested instance type has 8GB and 2vcp
                To get a list of valid values, use:
                aws ec2 describe-instance-types --query 'InstanceTypes[].InstanceType' --output table
          VAL: "{{.__vm}}"
          DEF: "t3a.large"
    - task: read
      vars:
          MSG: "AWS Disk Size to use for VMs"
          VAR: "AWS_VM_DISK_SIZE"
          VAL: "{{.__disk}}"
          DEF: "100"
    - task: read
      vars:
        MSG: "AWS public SSH key "
        HINT: |
              If you already have a public SSH key in AWS, provide its name here.
              If you do not have it, generate a key pair with the following command:
                ssh-keygen
              The public key defaults to ~/.ssh/id_rsa.pub and you can import with:
                aws ec2 import-key-pair --key-name nuvolaris-key --public-key-material --region=<your-region> fileb://~/.ssh/id_rsa.pub
        VAR: "AWS_SSHKEY"
        VAL: "{{.__key}}"
        DEF: "nuvolaris-key"


  eks:
    silent: true
    cmds:
    - test -n "$AWS_SECRET_ACCESS_KEY" || die "Please, configure first AWS with nuv config aws"
    - task: read
      vars:
        MSG: "EKS Name for Cluster and Node Group"
        VAR: "EKS_NAME"
        VAL: "{{.__name}}"
        DEF: "nuvolaris"
    - task: read
      vars:
        MSG: "EKS region"
        HINT: > 
              To get a list of valid values use:
                aws ec2 describe-regions --output table
        VAR: "EKS_REGION"
        VAL: "{{.__region}}"
        DEF: "us-east-1"
    - task: read
      vars:
        MSG: "EKS number of worker nodes"
        VAR: "EKS_COUNT"
        VAL: "{{.__count}}"
        DEF: "3"
    - task: read
      vars:
        MSG: "EKS virtual machine type"
        HINT: >
              To get a list of valid values, use:
                aws ec2 describe-instance-types --query 'InstanceTypes[].InstanceType' --output table 
        VAR: "EKS_VM"
        VAL: "{{.__vm}}"
        DEF: "m5.xlarge"
    - task: read
      vars:
        MSG: "EKS disk size in gigabyte"
        VAR: "EKS_DISK"
        VAL: "{{.__disk}}"
        DEF: "50"
    - task: read
      vars:
        MSG: "EKS Kubernetes Version"
        VAR: "EKS_KUBERNETES_VERSION"
        VAL: "{{.__kubever}}"
        DEF: "1.25"
    - config -d | grep EKS_

  gcloud:
    silent: true
    cmds:
    - task: readforce
      vars:
        MSG: "GCloud Project Id"
        VAR: "GCLOUD_PROJECT"
        VAL: "{{.__project}}"
    - task: read
      vars:
        MSG: "GCloud Zone"
        HINT: > 
              To get a list of valid values use:
                gcloud compute zones list
        VAR: "GCLOUD_REGION"
        VAL: "{{.__region}}"
        DEF: "us-east1"
    - task: read
      vars:
        MSG: "GCloud virtual machine type"
        HINT: >
              To get a list of valid values, use:
                gcloud compute machine-types list
        VAR: "GCLOUD_VM"
        VAL: "{{.__vm}}"
        DEF: "n2-standard-4"
    - task: read
      vars:
        MSG: "GCloud disk size in gigabyte"
        VAR: "GCLOUD_DISK"
        VAL: "{{.__disk}}"
        DEF: "200"
    - task: read
      vars:
          MSG: "GCloud public SSH key"
          HINT: >
                If you already have a public SSH key provide its path here.
                If you do not have it, generate a key pair with the following command:
                  ssh-keygen
                The public key defaults to ~/.ssh/id_rsa.pub.
          VAR: "GCLOUD_SSHKEY"
          VAL: "{{.__key}}"
          DEF: "~/.ssh/id_rsa.pub"          
    - config -d | grep GCLOUD_

  gke:
    silent: true
    cmds:
    - task: readforce
      vars:
        MSG: "GCloud Project Id"
        VAR: "GKE_PROJECT"
        VAL: "{{.__project}}"
    - task: read
      vars:
        MSG: "GCloud Cluster Name"
        HINT: >
              The cluster name must be unique.
        VAR: "GKE_NAME"
        VAL: "{{.__name}}"
        DEF: "nuvolaris"
    - task: read
      vars:
        MSG: "GCloud Cluster Zone"
        HINT: > 
              To get a list of valid values use:
                gcloud compute zones list
        VAR: "GKE_REGION"
        VAL: "{{.__region}}"
        DEF: "us-east1"
    - task: read
      vars:
        MSG: "GCloud number of worker nodes"
        VAR: "GKE_COUNT"
        VAL: "{{.__count}}"
        DEF: "3"
    - task: read
      vars:
        MSG: "GKE virtual machine type"
        HINT: >
              To get a list of valid values, use:
                gcloud compute machine-types list
        VAR: "GKE_VM"
        VAL: "{{.__vm}}"
        DEF: "e2-standard-2"
    - task: read
      vars:
        MSG: "GKE disk size in gigabyte"
        VAR: "GKE_DISK"
        VAL: "{{.__disk}}"
        DEF: "50"
    - config -d | grep GKE_

  aks:
    silent: true
    cmds:
    - task: read
      vars:
        MSG: "AKS Name for Cluster and Resource Group"
        VAR: "AKS_NAME"
        VAL: "{{.__name}}"
        DEF: "nuvolaris"
    - task: read
      vars:
        MSG: "AKS number of worker nodes"
        VAR: "AKS_COUNT"
        VAL: "{{.__count}}"
        DEF: "3"
    - task: read
      vars:
        MSG: "AKS location"
        HINT: >
              To get a list of valid values use:
                az account list-locations -o table
        VAR: "AKS_REGION"
        VAL: "{{.__region}}"
        DEF: "eastus"
    - task: read
      vars:
        MSG: "AKS virtual machine type"
        HINT: > 
              To get a list of valid values use:
                az vm list-sizes --location <location> -o table
              where <location> is your current location.
        VAR: "AKS_VM"
        VAL: "{{.__vm}}"
        DEF: "Standard_B4ms"
    - task: read
      vars:
        MSG: "AKS disk size in gigabyte"
        VAR: "AKS_DISK"
        VAL: "{{.__disk}}"
        DEF: "50"
    - task: read
      vars:
          MSG: "AKS public SSH key in AWS"
          HINT: >
                If you already have a public SSH key provide its path here.
                If you do not have it, generate a key pair with the following command:
                  ssh-keygen
                The public key defaults to ~/.ssh/id_rsa.pub.
          VAR: "AKS_SSHKEY"
          VAL: "{{.__key}}"
          DEF: "~/.ssh/id_rsa.pub"          
    - config -d | grep AKS_

  runtimes:
    silent: true
    cmds:
    - |
      if test -z "{{._runtimesjson_}}"
      then cat "{{.RUNTIMES}}"
      else  if test -e "{{._runtimesjson_}}"
            then cp "{{._runtimesjson_}}" $NUV_TMP/runtimes.json
                 echo "Imported runtimes.json from {{._runtimesjson_}}"
            else echo "not found {{._runtimesjson_}}"
            fi
      fi
    vars:
      RUNTIMES:
       sh: |
           if test -e "$NUV_TMP/runtimes.json"
           then echo "$NUV_TMP/runtimes.json"
           else echo ../setup/kubernetes/runtimes.json
           fi


  use:
    silent: true
    desc: select a different kubeconfig among those you created
    cmds:
    - |
      if ls "$NUV_TMP/*.kubeconfig" >/dev/null  2>/dev/null
      then
        if test -z "{{._n_}}"
        then N=1
            echo "*** Available kubeconfig (select by name or number):"
            echo "0  default kubeconfig (usually ~/.kube/config)"
            if test -e $NUV_TMP/kubeconfig
            then CUR="$(cat $NUV_TMP/kubeconfig)"
            else CUR=""
            fi
            for i in $NUV_TMP/*.kubeconfig
            do  K=$(basename $i)
                if test "$CUR" == "$(cat $NUV_TMP/$K)"
                then MSG="* "
                else MSG="  "
                fi
                echo "$((N++))$MSG${K%%.kubeconfig}"
            done
        else
          if [[ "{{._n_}}" == "0" ]]
          then rm $NUV_TMP/kubeconfig
               echo using default kubeconfig "${KK}" 
          else
            N=1
            for i in $NUV_TMP/*.kubeconfig
            do  K=$(basename $i)
                KK="${K%%.kubeconfig}"
                if [[ "$((N++))" = "{{._n_}}" || "$KK" = "{{._n_}}" ]]
                then  N=0
                      if {{.__delete}}
                      then echo removing kubeconfig "${KK}"
                          rm "$i"
                      elif test -n "{{.__rename}}"
                      then  NEWNAME="$(dirname $i)/{{.__rename}}.kubeconfig"
                            echo "renaming {{._n_}} to {{.__rename}}"
                            mv "$i" "$NEWNAME"
                      else
                        cp "$i" "$NUV_TMP/kubeconfig"
                        echo now using kubeconfig "${KK}"  
                        if kubectl --kubeconfig "$NUV_TMP/kubeconfig" cluster-info
                        then echo now using kubeconfig "${KK}" 
                        else echo "problems using this kubeconfig - removed"
                            rm "$NUV_TMP/kubeconfig"
                            echo please remove it with "nuv config use {{._n_}} --delete"
                        fi
                      fi
                      break
                fi
            done
            if test "$N" != "0"
            then echo not found kubeconfig "{{._n_}}"
            fi
          fi
        fi
      else echo "no available kubeconfig to use"
      fi

